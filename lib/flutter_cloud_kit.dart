import 'package:flutter_cloud_kit/types/cloud_ket_record.dart';
import 'package:flutter_cloud_kit/types/cloud_kit_account_status.dart';
import 'package:flutter_cloud_kit/types/database_scope.dart';

import 'flutter_cloud_kit_platform_interface.dart';

final _cloudKitIdentifierRegexp = RegExp(r'^[a-zA-Z]\w+$');
// couldn't use '*' instead of '+' in _cloudKitIdentifierRegexp because of the warning:
// Your expression contains a pattern that is known to freeze the browser with Javascript compiled version.
final _letterRegexp = RegExp(r'^[a-zA-Z]$');

// Needed because otherwise incorrect identifiers lead to Objective-C fatal errors
// that crash the app
// TODO: get rid of once Objective-C error handling is in place
void validateCloudKitIdentifier(String identifier) {
  bool isValidIdentifier = _letterRegexp.hasMatch(identifier) ||
      _cloudKitIdentifierRegexp.hasMatch(identifier);
  if (!isValidIdentifier) {
    throw Exception('Identifier "$identifier" is not valid for cloud kit');
  }
}

class FlutterCloudKit {
  final String? containerId;

  FlutterCloudKit({this.containerId});

  /// Gets the user's account status.
  Future<CloudKitAccountStatus> getAccountStatus() {
    return FlutterCloudKitPlatform.instance
        .getAccountStatus(containerId: containerId);
  }

  /// Saves the [record] with [recordType] to a CloudKit database of the
  /// provided [scope].
  /// [recordName] can also be specified. It's used for generating the record's
  /// id. If it's omitted, the id is generated by CloudKit.
  /// Throws if the [recordName] already exists for the provided [recordType].
  Future<void> saveRecord(
      {required CloudKitDatabaseScope scope,
      required String recordType,
      required Map<String, String> record,
      String? recordName}) {
    validateCloudKitIdentifier(recordType);
    record.keys.forEach(validateCloudKitIdentifier);
    return FlutterCloudKitPlatform.instance.saveRecord(
        containerId: containerId,
        scope: scope,
        recordType: recordType,
        record: record,
        recordName: recordName);
  }

  /// Gets record from CloudKit database with the provided [scope].
  /// [recordName] is used to generate the id to find the record by.
  Future<CloudKitRecord> getRecord(
      {required CloudKitDatabaseScope scope, required String recordName}) {
    return FlutterCloudKitPlatform.instance.getRecord(
        containerId: containerId, scope: scope, recordName: recordName);
  }

  /// Gets records by [recordType] from CloudKit database with the
  /// provided [scope].
  /// Sorts the returned records by creation time in ascending order.
  /// Doesn't support pagination yet, just returns a single batch of the
  /// maximum size.
  Future<List<CloudKitRecord>> getRecordsByType(
      {required CloudKitDatabaseScope scope, required String recordType}) {
    return FlutterCloudKitPlatform.instance.getRecordsByType(
        containerId: containerId, scope: scope, recordType: recordType);
  }

  /// Deletes the record by [recordName] from CloudKit database with the
  /// provided [scope].
  /// Throws if the record doesn't exist.
  Future<void> deleteRecord(
      {required CloudKitDatabaseScope scope, required String recordName}) {
    return FlutterCloudKitPlatform.instance.deleteRecord(
        containerId: containerId, scope: scope, recordName: recordName);
  }

  /// Saves multiple records to a CloudKit database of the provided [scope].
  /// Each record in the [records] list should be a map containing 'recordType',
  /// 'fields', and optionally 'recordName'.
  /// Returns a list of saved record IDs.
  Future<List<String>> saveRecords({
    required CloudKitDatabaseScope scope,
    required List<Map<String, dynamic>> records,
  }) async {
    for (var record in records) {
      validateCloudKitIdentifier(record['recordType'] as String);
      (record['fields'] as Map<String, dynamic>)
          .keys
          .forEach(validateCloudKitIdentifier);
    }
    return FlutterCloudKitPlatform.instance.saveRecords(
      containerId: containerId,
      scope: scope,
      records: records,
    );
  }
}
